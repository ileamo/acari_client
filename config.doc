Формат файла конфигурации.

<список> ::= [<элемент списка>, ...]
<список ключевых слов(keyword list)> ::= [<ключ>: <значение>, ...]
<ключ> ::= <последовательность букв, цифр, _, начинающаяся с буквы>
<значение> ::= <строка> | <число> |  <список> | <список ключевых слов> | true | false | function
<элемент списка> ::= <строка> | <число> |  <список> | <список ключевых слов> | true | false

<конфигурация клиента> ::= <список ключевых слов>


Ключи конфигурации клиента:
iface: описание интерфейса, <список ключевых слов>
links: описание линков, <список> где каждый элемент - описание конкретного линка


Ключи описания интерфейса:
name: имя интерфейса, строка
addr: адрес интерфейса, строка ("a.b.c.d/p"), обязательный параметр
peer: адрес пира, строка
broadcast: широковещетельный адрес, строка
tap: тип интерфейса (true/false)

addr, peer, broadcast - подставляются в команду
ip addr add dev <name> <addr> [peer <peer> broadcast <broadcast>]

Если имя интерфейса не задано, оно будет вычисленно автоматически (tunN, tapN)


<описание линка> ::= <список ключевых слов>

Ключи описания линка:
dev: имя интерфейса, строка
table: номер таблицы маршрутизации, число
restart_script: скрипт для рестарта линка, строка
gw: шлюз, строка или функция
servers: <список> серверов

Элемент списка серверов ::=  <список ключевых слов> - описание сервера

Ключи описания сервера:
host: адрес сервера, строка
port: порт, число


Использование функции в качестве значения параметра gw необходимо, если нельзя
задать этот параметр статически. Эта функция будет вызываться каждый раз, когда
системе нужно получить этот параметр, значение функции будет являтся значением
параметра. Функция - это анонимная функция, на языке Elixir.


Пример конфигурации:

[
  iface: [name: "acari0", addr: "172.16.13.91/32", peer: "172.16.0.1"],
  links: [
    [
      dev: "eth1",
      gw: fn ->
            case File.read("/var/dhcp/eth1/discardrouter") do
              {:ok, content} -> content
              _ -> nil
            end
          end,
      table: 100,
      servers: [
        [host: "185.157.97.4", port: 50019],
        [host: "185.157.97.5", port: 50019]
      ]
    ],
    [
      dev: "m1",
      table: 101,
      servers: [
        [host: "185.157.97.4", port: 50019],
        [host: "185.157.97.5", port: 50019]
      ],
      restart_script: "nsgsh -qr .port.m1.restart=nil"
    ],
    [
      dev: "m2",
      table: 102,
      servers: [
        [host: "185.157.97.4", port: 50019],
        [host: "185.157.97.5", port: 50019]
      ],
      restart_script: "nsgsh -qr .port.m2.restart=nil"
    ]
  ]
]

Для удобства написания конфигурации, можно использовать переменные, которым
предварительно присвоить части конфигурации. Например:

servers = [
  [host: "185.157.97.4", port: 50019],
  [host: "185.157.97.5", port: 50019]
]

get_gw = fn ->
  case File.read("/var/dhcp/eth1/discardrouter") do
    {:ok, content} -> content
    _ -> nil
  end
end

# Линки
eth1_link = [
  dev: "eth1",
  gw: get_gw,
  table: 100,
  servers: servers
]

m1_link = [
  dev: "m1",
  table: 101,
  servers: servers,
  restart_script: "nsgsh -qr .port.m1.restart=nil"
]

m2_link = [
  dev: "m2",
  table: 102,
  servers: servers,
  restart_script: "nsgsh -qr .port.m2.restart=nil"
]

# Конфигурация клиента
# Должна быть последним выражением в этом файле
[
  iface: [name: "acari0", addr: "172.16.13.91/32", peer: "172.16.0.1"],
  links: [eth1_link, m1_link, m2_link]
]

################################################################################

Строки, начинающиеся с решетки - являются комментарием
Ключ заканчивается двоеточием, пробел недопустим, после двоеточия пробел обязателен.

Ошибочный синтаксис:
[key : value]
[key:value]

Правильный синтаксис
[key: value]

(То есть двоеточие является обязательной частью имени ключа)
